// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.

#include "CorePrivatePCH.h"
#include "HTML5Application.h"
#include "HTML5Cursor.h"
#include "HTML5InputInterface.h"


#if PLATFORM_HTML5_BROWSER
#include "emscripten.h"
#include "html5.h"

EM_BOOL mouse_callback(int eventType, const EmscriptenMouseEvent *e, void *userData)
{
	return 1;
}

#endif 

static const uint32 MaxWarmUpTicks = 10; 

FHTML5Application* FHTML5Application::CreateHTML5Application()
{
	return new FHTML5Application();
}

FHTML5Application::FHTML5Application()
	: GenericApplication( MakeShareable( new FHTML5Cursor() ) )
	, ApplicationWindow(FHTML5Window::Make())
	, InputInterface( FHTML5InputInterface::Create(MessageHandler, Cursor ) )
	, WarmUpTicks(-1)
{

#if PLATFORM_HTML5_BROWSER
    // full screen will only be requested after the first click after the window gains focus. 
    // the problem is that because of security/UX reasons browsers don't allow pointer lock in main loop
    // but only through callbacks generated by browser. 

 	// work around emscripten bug where deffered browser requests are not called if there are no callbacks.
	emscripten_set_mousedown_callback("#canvas",0,1,mouse_callback);
#endif 

}


void FHTML5Application::SetMessageHandler( const TSharedRef< FGenericApplicationMessageHandler >& InMessageHandler )
{
	GenericApplication::SetMessageHandler(InMessageHandler);
	InputInterface->SetMessageHandler( MessageHandler );
}

void FHTML5Application::PollGameDeviceState( const float TimeDelta )
{
	SDL_Event Event;
	while (SDL_PollEvent(&Event)) 
	{
		// Tick Input Interface. 
		switch (Event.type)
		{
				case SDL_WINDOWEVENT: 
				{
					SDL_WindowEvent windowEvent = Event.window;


					// ignore resized client Height/Width
					int Width;
					int Height;
#if PLATFORM_HTML5_BROWSER
					int fs;
					emscripten_get_canvas_size(&Width, &Height, &fs);
#endif 

#if PLATFORM_HTML5_WIN32 
					Width = windowEvent.data1; 
					Height = windowEvent.data2; 
#endif 

					switch (windowEvent.event)
					{
					case SDL_WINDOWEVENT_SIZE_CHANGED:
						{
							MessageHandler->OnSizeChanged(ApplicationWindow,Width,Height, false);
							MessageHandler->OnResizingWindow(ApplicationWindow);

							FDisplayMetrics DisplayMetrics;
							FDisplayMetrics::GetDisplayMetrics(DisplayMetrics);
							BroadcastDisplayMetricsChanged(DisplayMetrics);
						}
						break;
					case SDL_WINDOWEVENT_RESIZED:
						{
							MessageHandler->OnResizingWindow(ApplicationWindow);

							FDisplayMetrics DisplayMetrics;
							FDisplayMetrics::GetDisplayMetrics(DisplayMetrics);
							BroadcastDisplayMetricsChanged(DisplayMetrics);
						}
						break;
					case SDL_WINDOWEVENT_ENTER:
						{
							MessageHandler->OnCursorSet();
							MessageHandler->OnWindowActivationChanged(ApplicationWindow, EWindowActivation::Activate); 
							WarmUpTicks = 0; 
						}
						break;
					case SDL_WINDOWEVENT_LEAVE:
						{
							MessageHandler->OnWindowActivationChanged(ApplicationWindow, EWindowActivation::Deactivate);
						}
						break;
					case SDL_WINDOWEVENT_FOCUS_GAINED:
						{
							MessageHandler->OnWindowActivationChanged(ApplicationWindow, EWindowActivation::Activate);
									WarmUpTicks = 0;
						}
						break;
					case SDL_WINDOWEVENT_FOCUS_LOST:
						{
							MessageHandler->OnWindowActivationChanged(ApplicationWindow, EWindowActivation::Deactivate);
						}
						break;
					 default:
						break;
					}
				}
			default:
			{
				InputInterface->Tick( TimeDelta,Event, ApplicationWindow);
			}
		}
	}
	InputInterface->SendControllerEvents();


	if ( WarmUpTicks >= 0)
		WarmUpTicks ++; 


	if ( WarmUpTicks == MaxWarmUpTicks  )
	{
        // browsers don't allow locking and hiding to work independently. use warmup ticks after the application has settled
        // on its mouse lock/visibility status.  This is necessary even in cases where the game doesn't want to locking because 
        // the lock status oscillates for few ticks before settling down. This causes a Browser UI pop even when we don't intend to lock.
        // see http://www.w3.org/TR/pointerlock more for information. 
#if PLATFORM_HTML5_WIN32
		SDL_Window* WindowHandle= SDL_GL_GetCurrentWindow();
		if (((FHTML5Cursor*)Cursor.Get())->LockStatus && !((FHTML5Cursor*)Cursor.Get())->CursorStatus)
		{
			SDL_SetWindowGrab(WindowHandle, SDL_TRUE);
			SDL_ShowCursor(SDL_DISABLE);
		    SDL_SetRelativeMouseMode(SDL_TRUE);
		}
		else
		{
			SDL_SetRelativeMouseMode(SDL_FALSE);
			SDL_ShowCursor(SDL_ENABLE);
			SDL_SetWindowGrab(WindowHandle, SDL_FALSE);
		}
#endif 

#if PLATFORM_HTML5_BROWSER
		if (((FHTML5Cursor*)Cursor.Get())->LockStatus && !((FHTML5Cursor*)Cursor.Get())->CursorStatus)
		{
			emscripten_request_pointerlock ( "#canvas" , true);
		}
		else
		{
			emscripten_exit_pointerlock(); 
		}
#endif 

		WarmUpTicks = -1; 
	}
}

FPlatformRect FHTML5Application::GetWorkArea( const FPlatformRect& CurrentWindow ) const
{
	return  FHTML5Window::GetScreenRect();
}

void FDisplayMetrics::GetDisplayMetrics(FDisplayMetrics& OutDisplayMetrics)
{
	OutDisplayMetrics.PrimaryDisplayWorkAreaRect = FHTML5Window::GetScreenRect();
	OutDisplayMetrics.VirtualDisplayRect    =	OutDisplayMetrics.PrimaryDisplayWorkAreaRect;
	OutDisplayMetrics.PrimaryDisplayWidth   =	OutDisplayMetrics.PrimaryDisplayWorkAreaRect.Right;
	OutDisplayMetrics.PrimaryDisplayHeight  =	OutDisplayMetrics.PrimaryDisplayWorkAreaRect.Bottom; 
}

TSharedRef< FGenericWindow > FHTML5Application::MakeWindow()
{
	return ApplicationWindow;
}
